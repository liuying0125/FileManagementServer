RAII 资源获取即初始化
在构造函数中申请资源，在西沟函数中释放资源，因为C++的语言机制保证了 当一个对象创建的时候，自动调用构造函数，当对象超过作用域的时候会自动调用析构函数  在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定

RAII的核心思想是将资源或者状态与对象的生命周期绑定，通过c++的语言机制，实现资源和状态的安全管理，智能指针是RAII的最好的 例子



---------------------------------------------------------------------------------

从状态机负责读取报文的一行，
主状态机负责对该行数据进行解析，
主状态机内部调用从状态机，从状态机驱动主状态机。

主状态机：
三种状态，标识解析位置
CHECK_STATE_REQUESTLINE，解析请求行

CHECK_STATE_HEADER，解析请求头

CHECK_STATE_CONTENT，解析消息体，仅用于解析POST请求

从状态机：
三种状态，标识解析一行的读取状态。
LINE_OK，完整读取一行

LINE_BAD，报文语法有误

LINE_OPEN，读取的行不完整

--------------------------------------------------------------------------------- 
Epoll：

水平触发(LT)：如果用户在监听epoll事件，当内核有事件的时候，会拷贝给用户态事件，但是如果用户只处理了一次，那么剩下没有处理的会在下一次 epoll_wait再次返回该事件。
这样如果用户永远不处理这个事件，就会导致每次都会有事件从内核到用户的拷贝，耗费性能，但是水平触发相对安全，最起码事件不会丢掉，除非用户处理完毕


 LT和ET模式是epoll操作文件描述符的两种方式。LT模式是默认的工作模式，相当于效率较高的poll；ET模式是epoll的高效模式


-------------------------定时器---------------------------

由于非活跃连接占用了连接资源，严重影响服务器的性能，通过实现一个服务器定时器，处理这种非活跃连接，释放连接资源。利用alarm函数周期性地触发SIGALRM信号,该信号的信号处理函数利用管道通知主循环执行定时器链表上的定时任务.

统一事件源
基于升序链表的定时器
处理非活动连接

 
管道通信：
#include<unistd.h>
int pipe(int filedes[2]);
pipe()会建立管道，并将文件描述词由参数filedes数组返回。
filedes[0]为管道里的读取端，filedes[1]则为管道的写入端。
返回值 若成功则返回零，否则返回-1，错误原因存于errno中。

错误代码 ：
        EMFILE：进程已用完文件描述词最大量。
        ENFILE：系统已无文件描述词可用。
        EFAULT：参数filedes数组地址不合法


 



信号：一个进程可以向另一个进程发送一个信号
9) SIGKILL	kill -9
不加任何 -   就是 15 号信号      15) SIGTERM

 
SIGTERM和SIGALRM
#define SIGALRM  14     //由alarm系统调用产生timer时钟信号
#define SIGTERM  15     //终端发送的终止信号

信号通知逻辑:
1、创建管道，其中管道写端写入信号值，管道读端通过I/O复用系统监测读事件
2、设置信号处理函数SIGALRM（时间到了触发）和SIGTERM（kill会触发，Ctrl+C）
3、通过struct sigaction结构体    和   sigaction函数   注册信号捕捉函数
4、在结构体的handler参数设置信号处理函数，具体的，从管道写端写入信号的名字

5、利用I/O复用系统监听管道读端文件描述符的可读事件

6、信息值传递给主循环，主循环再根据接收到的信号值执行目标信号对应的逻辑代码




数据库 3306端口  建立的TCP套接字      本机的话linux底层的套接字



-------------------------IO模型--------------------------

Unix有五种基本的IO模型：

1、阻塞式IO（守株待兔）
2、非阻塞式IO（没有就返回，直到有，其实是一种轮询（polling）操作）
3、IO复用（select、poll等，使系统阻塞在select或poll调用上，而不是真正的IO系统调用（如recvfrom），等待select返回可读才调用IO系统，其优势就在于可以等待多个描述符就位）
4、信号驱动式IO（sigio，即利用信号处理函数来通知数据已完备且不阻塞主进程）
5、异步IO（posix的aio_系列函数，与信号驱动的区别在于，信号驱动是内核告诉我们何时可以进行IO，而后者是内核通知何时IO操作已完成）

